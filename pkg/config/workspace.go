package config

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/sirupsen/logrus"
	"github.com/spf13/afero"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/yaml"
	"k8s.io/helm/pkg/chartutil"
	"k8s.io/helm/pkg/manifest"
	"k8s.io/helm/pkg/proto/hapi/chart"
	"k8s.io/helm/pkg/renderutil"

	"github.com/sidkik/kelda-v1/pkg/errors"
	"github.com/sidkik/kelda-v1/pkg/kube"
)

// Workspace contains the main development environment configuration.
type Workspace struct {
	Version  string    `json:"version,omitempty"`
	Services []Service `json:"services"` // Required.
	Tunnels  []Tunnel  `json:"tunnels"`
	Ignore   []string  `json:"ignore"`
	path     string
}

func (ws Workspace) getVersion() string {
	return ws.Version
}

func (ws Workspace) GetService(name string) (Service, bool) {
	for _, svc := range ws.Services {
		if svc.Name == name {
			return svc, true
		}
	}
	return Service{}, false
}

// Tunnel defines a desired tunnel between a local port and a service in the
// development environment.
type Tunnel struct {
	ServiceName string `json:"serviceName"` // Required.
	LocalPort   uint32 `json:"localPort"`   // Required.
	RemotePort  uint32 `json:"remotePort"`  // Required.
}

// Service contains the configuration required to boot a Microservice.
type Service struct {
	Name      string   `json:"name,omitempty"`
	Script    []string `json:"script"`
	Manifests []string `json:"manifests,omitempty"`
}

func (svc Service) GetDevCommand() ([]string, error) {
	pods, err := getPods(svc.Manifests)
	if err != nil {
		return nil, errors.WithContext(err, "parse pods in service")
	}

	if len(pods) != 1 || len(pods[0].Containers) != 1 {
		return nil, errors.NewFriendlyError("Failed to start development on %s.\n"+
			"Development is only supported for services with a single container.",
			svc.Name)
	}

	container := pods[0].Containers[0]
	if len(container.Args) != 0 {
		return nil, errors.NewFriendlyError("Failed to start development on %s.\n"+
			"Dev mode for pods with Args is not supported.\n"+
			"Please use Command, or explicitly specify a dev command in the service's kelda.yaml.",
			svc.Name)
	}

	if len(container.Command) == 0 {
		return nil, errors.NewFriendlyError("Failed to start development on %s.\n"+
			"Dev mode for pods without command is not supported.\n"+
			"Please explicitly specify a dev command in the service's kelda.yaml.",
			svc.Name)
	}
	return container.Command, nil
}

type parsedKubeObject struct {
	name string
	gvk  schema.GroupVersionKind
	raw  string
}

// InitialWorkspaceConfigVersion is the first version of the Kelda
// workspace config. Config files that do not specify a version
// will default to this version.
const InitialWorkspaceConfigVersion = "v1alpha1"

// SupportedWorkspaceConfigVersion is the supported version of the
// Kelda workspace config of the current Kelda binary.
const SupportedWorkspaceConfigVersion = "v1alpha1"

const (
	errParseHelmChart = `Failed to parse the Kubernetes YAML generated by the Helm chart at %q.
The files generated by 'helm template <chart>' should be deployable with 'kubectl apply'.

For debugging, the full error is shown below:
%s
`

	errParseFile = `Failed to parse the Kubernetes YAML at %q. It should be deployable with 'kubectl apply'.

For debugging, the full error is shown below:
%s
`

	errParseScriptOutput = `Failed to parse the Kubernetes YAML generated by '%s'. ` +
		`It should be deployable with 'kubectl apply'.

For debugging, the full error is shown below:
%s
`
)

// ParseWorkspace parses the config file at `cfgPath`.
func ParseWorkspace(syncLogger *logrus.Logger, cfgPath string, ns string) (Workspace, error) {
	config := Workspace{Version: InitialWorkspaceConfigVersion, path: cfgPath}
	if err := parseConfig(cfgPath, &config, SupportedWorkspaceConfigVersion); err != nil {
		return Workspace{}, errors.WithContext(err, "parse")
	}

	skipFiles := map[string]struct{}{
		".DS_Store":  {},
		".git":       {},
		".gitignore": {},
		"kelda.log":  {},
		"LICENSE":    {},
	}
	for _, ignore := range config.Ignore {
		skipFiles[ignore] = struct{}{}
	}

	var serviceDirectories []string
	var scriptServices []Service
	if len(config.Services) == 0 {
		// Deploy all the YAML in the Workspace directory if no services are
		// specified explicitly.
		serviceDirectories = []string{"."}
		skipFiles[filepath.Base(cfgPath)] = struct{}{}
	} else {
		for _, svc := range config.Services {
			if len(svc.Script) == 0 && svc.Name == "" {
				return Workspace{}, errors.NewFriendlyError(
					"Please fix your workspace.yml file.\n" +
						"The name field is required for services that don't have a script field.")
			}

			if len(svc.Script) != 0 {
				scriptServices = append(scriptServices, svc)
				continue
			}

			serviceDirectories = append(serviceDirectories, svc.Name)

			dirPath := filepath.Join(filepath.Dir(cfgPath), svc.Name)
			if _, err := fs.Stat(dirPath); os.IsNotExist(err) {
				return Workspace{}, errors.NewFriendlyError(
					"Kubernetes YAML directory for service %q does not exist.\n"+
						"Each service in the Workspace configuration must have a "+
						"corresponding directory containing the Kubernetes YAML for "+
						"deploying the service.\n\n"+
						"See http://docs.kelda.io/reference/configuration/"+
						"#workspace-configuration for more information.", svc.Name)
			}
		}
	}

	var services []Service

	var ignoredFiles []string
	for _, dir := range serviceDirectories {
		dirPath := filepath.Join(filepath.Dir(cfgPath), dir)
		dirServices, dirIgnoredFiles, err := getServicesInDirectory(dirPath, skipFiles)
		if err != nil {
			return Workspace{}, errors.WithContext(err, "get services")
		}

		if dir != "." {
			dirServices = renameServices(dir, dirServices)
		}
		services = append(services, dirServices...)
		ignoredFiles = append(ignoredFiles, dirIgnoredFiles...)
	}

	if syncLogger != nil && len(ignoredFiles) != 0 {
		syncLogger.Warnf("Not deploying the following non-YAML files: %s", ignoredFiles)
	}

	for _, svc := range scriptServices {
		subServices, err := getServicesForScript(filepath.Dir(cfgPath), svc, ns)
		if err != nil {
			return Workspace{}, errors.WithContext(err, "get services for script")
		}

		services = append(services, subServices...)
	}

	config.Services = services
	if err := config.lint(); err != nil {
		return Workspace{}, err
	}
	return config, nil
}

func getServicesForScript(cmdDir string, svc Service, ns string) (services []Service, err error) {
	if len(svc.Script) == 0 {
		return nil, errors.New("service has no script")
	}

	var stdout, stderr bytes.Buffer
	cmd := exec.Command(svc.Script[0], svc.Script[1:]...)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	cmd.Dir = cmdDir
	cmd.Env = append(os.Environ(),
		"KELDA_NAMESPACE="+ns,
	)
	if err := cmd.Run(); err != nil {
		return nil, errors.NewFriendlyError(
			"Failed to render the YAML for %q.\n\n"+
				"Got error: %s\n"+
				"'%s' printed:\n\n%s",
			svc.Name, err, strings.Join(svc.Script, " "), stderr.String())
	}

	objects, err := parseYAML(&stdout)
	if err != nil {
		return nil, errors.NewFriendlyError(
			fmt.Sprintf(errParseScriptOutput, strings.Join(svc.Script, " "), err))
	}

	return renameServices(svc.Name, splitServices(objects)), nil
}

func getServicesInDirectory(dir string, skipFiles map[string]struct{}) (
	services []Service, ignoredFiles []string, err error) {

	// If the directory is a Helm chart, ignore the rest of the files.
	if _, err := fs.Stat(filepath.Join(dir, "Chart.yaml")); err == nil {
		helmFiles, err := renderHelmChart(dir)
		if err != nil {
			return nil, nil, err
		}

		return splitServices(helmFiles), nil, nil
	}

	// Create a service from the YAML files in the directory, and parse any
	// services in subdirectories.
	files, err := afero.ReadDir(fs, dir)
	if err != nil {
		return nil, nil, errors.WithContext(err, "read directory contents")
	}

	var parsedKubeObjects []parsedKubeObject
	for _, fi := range files {
		filename := fi.Name()
		if _, ok := skipFiles[filename]; ok {
			continue
		}

		fullpath := filepath.Join(dir, filename)
		if fi.IsDir() {
			subServices, subIgnoredFiles, err := getServicesInDirectory(fullpath, skipFiles)
			if err != nil {
				return nil, nil, errors.WithContext(err, "get services in subdir")
			}

			ignoredFiles = append(ignoredFiles, subIgnoredFiles...)
			services = append(services, renameServices(filename, subServices)...)
			continue
		}

		if !strings.HasSuffix(filename, ".yml") &&
			!strings.HasSuffix(filename, ".yaml") {
			ignoredFiles = append(ignoredFiles, fullpath)
			continue
		}

		// A YAML file that should be deployed by Kelda.
		f, err := fs.Open(fullpath)
		if err != nil {
			return nil, nil, errors.WithContext(err,
				fmt.Sprintf("open file %q", fullpath))
		}

		parsed, err := parseYAML(f)
		if err != nil {
			f.Close()
			return nil, nil, errors.NewFriendlyError(
				fmt.Sprintf(errParseFile, fullpath, err))
		}
		f.Close()

		parsedKubeObjects = append(parsedKubeObjects, parsed...)
	}

	services = append(services, splitServices(parsedKubeObjects)...)
	return services, ignoredFiles, nil
}

// splitServices splits up a list of Kubernetes objects into services that each
// contain at most one pod controller.
func splitServices(manifests []parsedKubeObject) []Service {
	if len(manifests) == 0 {
		return nil
	}

	var controllers []parsedKubeObject
	var nonControllers []parsedKubeObject
	for _, manifest := range manifests {
		switch manifest.gvk.Kind {
		// Create a separate service for the following controllers.
		case "Deployment", "DaemonSet", "Job", "StatefulSet":
			controllers = append(controllers, manifest)
		default:
			nonControllers = append(nonControllers, manifest)
		}
	}

	if len(controllers) == 0 {
		return []Service{
			{Name: "default", Manifests: toStrings(nonControllers)},
		}
	}

	// It's possible for two objects to have the same name if they're different
	// kinds. If this happens, we distinguish the services by appending their
	// object kind.
	nameConflicts := map[string][]parsedKubeObject{}
	for _, manifest := range controllers {
		nameConflicts[manifest.name] = append(nameConflicts[manifest.name], manifest)
	}

	var services []Service
	for name, conflicts := range nameConflicts {
		if len(conflicts) == 1 {
			services = append(services, Service{
				Name:      strings.ToLower(name),
				Manifests: []string{conflicts[0].raw},
			})
			continue
		}

		for _, conflict := range conflicts {
			services = append(services, Service{
				Name:      strings.ToLower(fmt.Sprintf("%s-%s", name, conflict.gvk.Kind)),
				Manifests: []string{conflict.raw},
			})
		}
	}

	// Sort the services so that we consistently add the nonControllerManifests
	// to the same services. This way, re-running `kelda dev` doesn't result in
	// any unnecessary shifting of manifests.
	byName := func(i, j int) bool { return services[i].Name < services[j].Name }
	sort.Slice(services, byName)

	nonControllerManifests := toStrings(nonControllers)
	sort.Strings(nonControllerManifests)
	services[0].Manifests = append(services[0].Manifests, nonControllerManifests...)
	return services
}

// renameServices renames the services in a directory so that they're unique.
// If the directory name is empty, it does nothing.
// If there's only one service, then we just rename it to be the same as the
// directory name.
// If there are multiple services, then we use the directory name as a prefix
// for the service names.
func renameServices(dirName string, services []Service) (renamed []Service) {
	if dirName == "" {
		return services
	}

	if len(services) == 1 {
		svc := services[0]
		svc.Name = dirName
		return []Service{svc}
	}

	for _, svc := range services {
		svc.Name = fmt.Sprintf("%s-%s", dirName, svc.Name)
		renamed = append(renamed, svc)
	}
	return renamed
}

func renderHelmChart(chartPath string) ([]parsedKubeObject, error) {
	chrt, err := chartutil.LoadDir(chartPath)
	if err != nil {
		return nil, errors.WithContext(err, "load chart")
	}

	// We must use this chart option rather than `nil` so that the default
	// values in the chart are incorporated.
	chartOpts := &chart.Config{Raw: "{}"}
	renderedTemplates, err := renderutil.Render(chrt, chartOpts, renderutil.Options{})
	if err != nil {
		return nil, errors.NewFriendlyError("Failed to convert the Helm chart into Kubernetes YAML.\n"+
			"To debug this directly, try running `helm template <chart>`, "+
			"and make sure that Helm doesn't generate any errors.\n\n"+
			"The full error message is reproduced below:\n%s", err)
	}

	var objects []parsedKubeObject
	for _, m := range manifest.SplitManifests(renderedTemplates) {
		// Ignore empty manifests.
		if strings.TrimSpace(m.Content) == "" {
			continue
		}

		parsed, err := parseYAML(bytes.NewBufferString(m.Content))
		if err != nil {
			return nil, errors.NewFriendlyError(
				fmt.Sprintf(errParseHelmChart, chartPath, err))
		}
		objects = append(objects, parsed...)
	}
	return objects, nil
}

func parseYAML(input io.Reader) (parsed []parsedKubeObject, err error) {
	reader := yaml.NewYAMLReader(bufio.NewReader(input))
	for {
		document, err := reader.Read()
		if err == io.EOF {
			return parsed, nil
		} else if err != nil {
			return nil, errors.WithContext(err, "split YAML file")
		}

		obj, err := kube.Parse(document)
		if err != nil {
			return nil, errors.WithContext(err, "parse Kubernetes object")
		}

		parsed = append(parsed, parsedKubeObject{
			raw:  string(document),
			gvk:  obj.GroupVersionKind(),
			name: obj.GetName(),
		})
	}
}

func (ws Workspace) lint() error {
	if len(ws.Services) == 0 {
		return errors.NewFriendlyError(
			"No Kubernetes YAML found in the Workspace directory for %s.\n"+
				"See kelda.io/docs/reference/configuration/#workspace-configuration for more information.",
			ws.path)
	}

	for _, tunnel := range ws.Tunnels {
		if tunnel.ServiceName == "" || tunnel.LocalPort == 0 || tunnel.RemotePort == 0 {
			return errors.NewFriendlyError(
				"A tunnel in %s is missing a required field.\n"+
					"The following fields are required:\n"+
					"* serviceName: a string denoting the name of the service to connect to.\n"+
					"* remotePort: the port number on the remote pod.\n"+
					"* localPort: the port number on your local machine.\n\n"+
					"See kelda.io/docs/reference/configuration/#tunnels for more information.", ws.path)
		}

		if _, ok := ws.GetService(tunnel.ServiceName); !ok {
			var serviceList []string
			for _, svc := range ws.Services {
				serviceList = append(serviceList, svc.Name)
			}
			sort.Strings(serviceList)
			return errors.NewFriendlyError(
				"A tunnel in %s refers to service %q, which does not exist.\n\n"+
					"The valid service names are: [%s]", ws.path, tunnel.ServiceName, strings.Join(serviceList, ", "))
		}
	}

	return nil
}

func toStrings(parsed []parsedKubeObject) (strs []string) {
	for _, m := range parsed {
		strs = append(strs, m.raw)
	}
	return strs
}

func getPods(manifests []string) (pods []corev1.PodSpec, err error) {
	for _, manifest := range manifests {
		obj, err := kube.Parse([]byte(manifest))
		if err != nil {
			return nil, errors.WithContext(err, "parse object")
		}

		switch obj.GroupVersionKind().Kind {
		// The supported pod controllers.
		case "Deployment", "DaemonSet", "Job", "StatefulSet":
		default:
			continue
		}

		unstructuredPodSpec, _, err := unstructured.NestedMap(obj.Object, "spec", "template", "spec")
		if err != nil {
			return nil, errors.WithContext(err, "get podSpec")
		}

		var podSpec corev1.PodSpec
		if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredPodSpec, &podSpec); err != nil {
			return nil, errors.WithContext(err, "parse podSpec")
		}
		pods = append(pods, podSpec)
	}
	return
}
