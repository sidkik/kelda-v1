package minion

import (
	"io/ioutil"

	"github.com/spf13/cobra"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/restmapper"

	"github.com/sidkik/kelda-v1/cmd/setup"
	"github.com/sidkik/kelda-v1/cmd/util"
	"github.com/sidkik/kelda-v1/pkg/analytics"
	"github.com/sidkik/kelda-v1/pkg/config"
	keldaClientset "github.com/sidkik/kelda-v1/pkg/crd/client/clientset/versioned"
	"github.com/sidkik/kelda-v1/pkg/crd/controller/microservice"
	"github.com/sidkik/kelda-v1/pkg/errors"
	minionServer "github.com/sidkik/kelda-v1/pkg/minion/server"
)

// New creates a new `minion` command.
func New() *cobra.Command {
	return &cobra.Command{
		Use: "minion",
		Short: "The Kelda in-cluster component. The minion communicates with " +
			"the Kubernetes API to create development environments. This command " +
			"should not be used directly.",
		Hidden: true,
		Annotations: map[string]string{
			util.AnalyticsNamespaceKey:     "minion",
			util.UseInClusterKubeClientKey: "true",
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			licenseBytes, err := ioutil.ReadFile(setup.LicensePathInMinion)
			if err != nil {
				return err
			}

			license, err := config.ParseLicense(string(licenseBytes))
			if err != nil {
				return err
			}
			analytics.SetCustomer(license.Terms.Customer)

			// Trial licenses don't have to be signed -- they are just
			// generated by the CLI.
			if license.Terms.Type == config.Customer && !license.Signed {
				return errors.New("license signature verification failed")
			}

			config, err := rest.InClusterConfig()
			if err != nil {
				return err
			}

			kubeClientset, err := kubernetes.NewForConfig(config)
			if err != nil {
				return err
			}

			groupResources, err := restmapper.GetAPIGroupResources(kubeClientset.Discovery())
			if err != nil {
				return err
			}

			keldaClientset, err := keldaClientset.NewForConfig(config)
			if err != nil {
				return err
			}

			rm := restmapper.NewDiscoveryRESTMapper(groupResources)
			go func() {
				defer util.HandlePanic()
				microservice.Run(*config, kubeClientset, rm, keldaClientset)
			}()
			return minionServer.Run(license, kubeClientset, keldaClientset)
		},
	}
}
